{
  "array": [
  {
    "text": "import java.util.Arrays;\n\npublic class BubbleSort {\n\n\tstatic void sort(int [] arrA){\n\t\tif(arrA==null || arrA.length==0)\n\t\t\treturn;\n\n\t\tSystem.out.println(\"Original Array: \" + Arrays.toString(arrA));\n\t\tint size = arrA.length;\n\t\tfor (int i = 0; i <size-1 ; i++) {\n\t\t\tfor (int j = 0; j <size-i-1 ; j++) {\n\t\t\t\t//check the adjacent elements\n\t\t\t\tif(arrA[j]>arrA[j+1]){\n\t\t\t\t\t//swap the elements\n\t\t\t\t\tint temp = arrA[j];\n\t\t\t\t\tarrA[j] = arrA[j+1];\n\t\t\t\t\tarrA[j+1] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Sorted Array: \" +  Arrays.toString(arrA));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint [] arrA = {5, 1, 9, 3, 2, 10};\n\t\tsort(arrA);\n\t}\n}",
    "difficulty": 5.0,
    "explanation": "This code is an implementation of the Bubble Sort algorithm in Java. The Bubble Sort algorithm is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares adjacent elements and swaps them if they are in the wrong order. The algorithm gets its name from the way smaller elements \"bubble\" to the top of the list.\n\nThe code begins by importing the java.util.Arrays package which provides utility methods for working with arrays. The BubbleSort class contains a single static method sort() that takes an array of integers arrA as its parameter. The method first checks if the input array is empty or null, and if so, it returns without performing any sorting.\n\nIf the array is not empty, the method prints the original array using the Arrays.toString() method. It then initializes a variable size to the length of the input array. The method then enters into a nested for loop to compare and swap adjacent elements in the array. The outer loop runs from i = 0 to i = size-1 and the inner loop runs from j = 0 to j = size-i-1. At each iteration, the adjacent elements arrA[j] and arrA[j+1] are compared, and if arrA[j] is greater than arrA[j+1], the two elements are swapped using a temporary variable temp.\n\nAfter completing the nested for loop, the method prints the sorted array using Arrays.toString(). Finally, there is a main() method that creates an array of integers arrA and passes it to the sort() method to sort the array.\n\nOverall, this code implements the Bubble Sort algorithm in Java to sort an array of integers in ascending order."
  },
  {
    "text": "import com.lowagie.text.Document;\nimport com.lowagie.text.Paragraph;\nimport com.lowagie.text.pdf.PdfWriter;\n\npublic class GeneratePDF {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tOutputStream file = new FileOutputStream(new File(\"C:\\\\Test.pdf\"));\n\n\t\t\tDocument document = new Document();\n\t\t\tPdfWriter.getInstance(document, file);\n\t\t\tdocument.open();\n\t\t\tdocument.add(new Paragraph(\"Hello Kiran\"));\n\t\t\tdocument.add(new Paragraph(new Date().toString()));\n\n\t\t\tdocument.close();\n\t\t\tfile.close();\n\n\t\t} catch (Exception e) {\n\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}",
    "difficulty": 2.0,
    "explanation": "This code is a Java program that generates a PDF file using the iText library, which provides APIs for working with PDF documents. The program creates a simple PDF document with a heading and a date stamp and saves it to a file named \"Test.pdf\" in the C drive.\n\nThe code begins with importing the necessary classes from the iText library: Document, Paragraph, and PdfWriter. The GeneratePDF class contains a single main() method that generates the PDF file.\n\nInside the main() method, a try-catch block is used to handle any exceptions that may be thrown during the PDF generation process. Within the try block, an output stream file is created to write the PDF file to the C drive.\n\nNext, a new Document object is created. This object represents the PDF document to be generated. The PdfWriter class is then used to create an instance of a PdfWriter that writes to the file output stream.\n\nThe document is then opened using the open() method and a Paragraph object is added to the document with the text \"Hello Kiran\". A second Paragraph object is added to the document with a Date object converted to a String.\n\nFinally, the document is closed with the close() method to ensure that any pending changes are written to the PDF file. The file output stream is also closed to release any resources used during the PDF generation process.\n\nIf an exception is thrown during the PDF generation process, it will be caught by the catch block, and the stack trace will be printed to the console.\n\nIn summary, this code demonstrates how to use the iText library to generate a simple PDF document with a heading and a date stamp and save it to a file using a Java program."
  },
  {
    "text": "public void postMail( String recipients[ ], String subject, String message , String from) throws MessagingException\n{\n\tboolean debug = false;\n\n\t //Set the host smtp address\n\t Properties props = new Properties();\n\t props.put(\"mail.smtp.host\", \"smtp.example.com\");\n\n\t// create some properties and get the default Session\n\tSession session = Session.getDefaultInstance(props, null);\n\tsession.setDebug(debug);\n\n\t// create a message\n\tMessage msg = new MimeMessage(session);\n\n\t// set the from and to address\n\tInternetAddress addressFrom = new InternetAddress(from);\n\tmsg.setFrom(addressFrom);\n\n\tInternetAddress[] addressTo = new InternetAddress[recipients.length]; \n\tfor (int i = 0; i < recipients.length; i++)\n\t{\n\t\taddressTo[i] = new InternetAddress(recipients[i]);\n\t}\n\tmsg.setRecipients(Message.RecipientType.TO, addressTo);\n   \n\n\t// Optional : You can also set your custom headers in the Email if you Want\n\tmsg.addHeader(\"MyHeaderName\", \"myHeaderValue\");\n\n\t// Setting the Subject and Content Type\n\tmsg.setSubject(subject);\n\tmsg.setContent(message, \"text/plain\");\n\tTransport.send(msg);\n}",
    "difficulty": 4.0,
    "explanation": "This code defines a method called postMail that sends an email message to one or more recipients using the Simple Mail Transfer Protocol (SMTP).\n\nThe method takes in four arguments: an array of recipient email addresses, the email subject, the email message content, and the email address of the sender. The method throws a MessagingException if an error occurs during the email sending process.\n\nThe method first sets a boolean value to false to indicate that debugging is turned off. It then creates a Properties object to hold the host SMTP address, sets the value of mail.smtp.host property to smtp.example.com, and obtains the default Session instance using these properties.\n\nNext, the method creates a new Message instance, sets the sender and recipient email addresses, and adds a custom header (if desired). The email subject and content type are also set using the setSubject and setContent methods, respectively.\n\nFinally, the Transport.send method is called to send the message. The message is sent to all recipients using the TO recipient type."
  },
  {
    "text": "public static <T> T[] shuffle(T[] input) {\n\t\tT[] arr = Arrays.copyOf(input, input.length);\n\t\tint length = arr.length;\n\t\tint m = length;\n\t\twhile (m > 0) {\n\t\t\tint i = (int) Math.floor(Math.random() * m--);\n\t\t\tT tmp = arr[i];\n\t\t\tarr[i] = arr[m];\n\t\t\tarr[m] = tmp;\n\t\t}\n\t\treturn arr;\n\t}",
    "difficulty": 2.0,
    "explanation": "This code snippet defines a method called shuffle that takes an array of type T as input, and returns a shuffled version of the input array.\n\nThe method first creates a copy of the input array using the Arrays.copyOf method, and stores it in a new array called arr.\n\nThen, the method initializes a variable called m to the length of the array, and enters a while loop that continues until m is decremented to zero.\n\nIn each iteration of the loop, the method generates a random integer i between 0 (inclusive) and m (exclusive) using the Math.random() method, and then swaps the elements at indices i and m-1 in the arr array.\n\nFinally, the method returns the shuffled arr array.\n\nOverall, this code implements the Fisher-Yates shuffle algorithm to shuffle the elements of an array in a random order."
  },
  {
    "text": "/**\n   * Factorial. Example of what the recursive implementation looks like.\n   *\n   * @param number for which factorial is to be calculated for\n   * @return factorial\n   */\n  public static int recursiveFactorial(int number) {\n\tvar initial = 0;\n\tif (number == initial) {\n\t  return initial + 1;\n\t}\n\treturn number * recursiveFactorial(number - 1);\n  }",
    "difficulty": 1.0,
    "explanation": "This code snippet is a Java implementation of a recursive function to calculate the factorial of a given number. The function takes an integer parameter named \"number\" and returns an integer representing the factorial of that number.\n\nThe code first initializes a variable named \"initial\" to zero. If the \"number\" parameter equals \"initial,\" which means it is zero, then the function returns the value of \"initial + 1,\" which is one.\n\nIf the \"number\" parameter is greater than zero, the function recursively calls itself with the argument \"number - 1\" and multiplies the result by the original \"number\" parameter. The recursion continues until the base case is reached when the \"number\" parameter is equal to zero.\n\nFor example, if the input number is 5, the function would call itself with the argument 4, which would call itself with the argument 3, and so on until it reaches 1. At that point, the function would return the value 1. The value returned by each recursive call is then multiplied together to get the final result, which is 5 * 4 * 3 * 2 * 1 = 120.\n\n\n\n"
  },
  {
    "text": "public List<Node> breadthFirstSearch(String rootName) {\n\tList<Node> result = new ArrayList<Node>();\n\tList<Node> temp = new ArrayList<Node>();\n\tSet<String> visited = new HashSet<String>();\n\n\tNode root = nodes.get(rootName);\n\ttemp.add(root);\n\tvisited.add(rootName);\n\n\twhile (temp.size() > 0) {\n\t  Node currentNode = temp.get(0);\n\t  List<Node> neighbors = currentNode.getNeighbors();\n\n\t  for (int i = 0; i < neighbors.size(); i++) {\n\t\tNode neighbor = neighbors.get(i);\n\n\t// a node can only be visited once if it has more than one parents \n\t\tif (visited.contains(neighbor.getName())) {\n\t\t  continue;\n\t\t} else {\n\t\t  temp.add(neighbor);\n\t\t  visited.add(neighbor.getName());\n\t\t}\n\t  }\n\n\t  temp.remove(0);\n\t  result.add(currentNode);\n\t}\n\n\treturn result;\n  }",
    "difficulty": 6.0,
    "explanation": "This code snippet implements a Breadth-First Search (BFS) algorithm on a graph data structure. The input parameter is the name of the root node to start the search from.\n\nThe method initializes an empty list result to hold the nodes that are visited in the order they are traversed. It also creates an empty list temp and a set visited to keep track of the nodes that have been visited.\n\nIt starts by getting the Node object associated with the rootName from a Map called nodes and adding it to the temp list. It also adds the rootName to the visited set.\n\nThe method then enters a while loop that runs as long as there are nodes in the temp list. Inside the loop, it retrieves the first node in temp list and gets its neighbors. It loops through each neighbor and checks if it has been visited before by checking if its name is in the visited set. If it has not been visited before, it adds it to the temp list and the visited set. If it has been visited, it skips the neighbor and moves to the next neighbor.\n\nAfter visiting all the neighbors of the current node, the current node is removed from the temp list and added to the result list. The loop continues until there are no more nodes in the temp list. Finally, the method returns the result list containing the visited nodes in the order they were traversed.\n\nOverall, this method implements the Breadth-First Search algorithm to traverse a graph starting from a specified root node and returns a list of visited nodes in the order they were traversed."
  },
  {
    "text": "public class Add{\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tint first = 10;\n\t\tint second = 20;\n\n\t\tint sum = first + second;\n\n\t\tSystem.out.println(\"The sum is: \" + sum);\n\t}\n}",
    "difficulty": 1.0,
    "explanation": "This is a Java program that calculates the sum of two integers and prints the result to the console.\n\nThe public class Add line declares a new public class called Add. Within the class, there is a public static void main(String[] args) method which serves as the entry point of the program.\n\nWithin the main method, two integer variables first and second are declared and initialized with values of 10 and 20 respectively.\n\nThe sum of the two integers is then calculated and stored in the integer variable sum.\n\nFinally, the result is printed to the console using the System.out.println() method. The text \"The sum is: \" is concatenated with the value of sum using the + operator, and the resulting string is passed to the println() method to display the result."
  },
  {
    "text": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *\t int val;\n *\t ListNode next;\n *\t ListNode(int x) {\n *\t\t val = x;\n *\t\t next = null;\n *\t }\n * }\n */\npublic class Solution {\n\tpublic ListNode removeNthFromEnd(ListNode head, int n) {\n\t\tListNode cur = head, prev = head;\n\t\twhile(n-- > 0) {\n\t\t\tcur = cur.next;\n\t\t}\n\t\tif (cur == null) \n\t\t\treturn head.next;\n\t\twhile (cur.next != null) {\n\t\t\tcur = cur.next;\n\t\t\tprev = prev.next;\n\t\t}\n\t\tprev.next = prev.next.next;\n\t\treturn head;\n\t}\n}",
    "difficulty": 3.0,
    "explanation": "This code defines a Solution class with a method called removeNthFromEnd which takes a singly-linked list head and an integer n as input, and returns the updated list with the nth node from the end removed.\n\nThe code starts by initializing two pointers cur and prev to the head of the list. The cur pointer is then moved n steps forward in the list. This effectively positions cur at the nth node from the beginning of the list.\n\nNext, a loop is executed until cur reaches the end of the list. In each iteration, both cur and prev pointers are moved one step forward. At the end of this loop, prev will be positioned at the node right before the nth node from the end of the list.\n\nFinally, the next pointer of prev is set to prev.next.next to remove the nth node from the end, and the updated head of the list is returned. If the cur pointer had reached the end of the list in the first loop, indicating that the nth node from the end is actually the head of the list, the method simply returns head.next.\n\n\n\n"
  },
  {
    "text": "package complexconditionals;\n\nimport java.util.*;\n\npublic class ComplexConditionals {\n\tpublic static void main(String[] args) {\n\t\tScanner reader = new Scanner(System.in);\n\t\tString input = reader.next();\n\t\tString sOne = \"abc\";\n\t\tString sTwo = \"z\";\n\t\t\n\t\tboolean bool1 = input.contains(sOne);\n\t\tboolean bool2 = input.contains(sTwo);\n\t\t\n\t\tif((bool1 || bool2) && false)\n\t\t{\n\t\t\tSystem.out.println(\"TRUE\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(\"FALSE\");\n\t\t}\n\t}\n}",
    "difficulty": 2.0,
    "explanation": "This code snippet defines a Java class named \"ComplexConditionals\" that contains a main method. When the program is run, it prompts the user to enter a string input using the Scanner class.\n\nThe program then initializes two string variables, sOne and sTwo, with the values \"abc\" and \"z\", respectively.\n\nThe program then checks whether the input string contains sOne or sTwo using the contains() method of the String class and assigns the resulting boolean values to the variables bool1 and bool2, respectively.\n\nThe program then checks whether bool1 or bool2 is true and false is false, and if so, prints \"TRUE\". Otherwise, it prints \"FALSE\".\n\nIn summary, the code snippet demonstrates the use of complex conditionals using boolean operators and the String class's contains() method in Java."
  },
  {
    "text": "public class WritingXML {\n\tpublic static void main(String[] args) {\n\t\tFile xmlFile = new File(\"cars.xml\");\n\t\tDocument dom = LoadXMLDocument(xmlFile);\n\t\t\n\t\tNodeList owners = dom.getElementsByTagName(\"owner\");\n\t\tfor(int i = 0; i < owners.getLength(); i++)\n\t\t{\n\t\t\tElement owner = (Element)owners.item(i);\n\t\t\towner.setAttribute(\"name\", \"Mike\");\n\t\t}\n\t\t\n\t\tWriteXMLDocument(dom, xmlFile);\n\t}\n\t\n\tprivate static void WriteXMLDocument(Document doc, File destination)\n\t{\n\t\ttry{\n\t\t\t// Write doc to destination file here...\n\t\t\tTransformerFactory tf = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = tf.newTransformer();\n\t\t\tStreamResult result = new StreamResult(destination);\n\t\t\tDOMSource source = new DOMSource(doc);\n\t\t\t\n\t\t\ttransformer.transform(source, result);\n\t\t}\n\t\tcatch(TransformerConfigurationException e)\n\t\t{\n\t\t\tSystem.err.println(\"XML writing failed.\");\n\t\t}\n\t\tcatch(TransformerException e)\n\t\t{\n\t\t\tSystem.err.println(\"XML writing failed.\");\n\t\t}\n\t}\n\t\n\tprivate static Document LoadXMLDocument(File source)\n\t{\n\t\tDocument dom = null;\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\n\t\ttry {\n\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\tdom = builder.parse(source);\n\t\t}\n\t\tcatch (ParserConfigurationException e) {\n\t\t\t System.err.println(\"XML loading failed.\");\n\t\t} \n\t\tcatch (SAXException e) {\n\t\t\t System.err.println(\"XML loading failed.\");\n\t\t} \n\t\tcatch (IOException e) {\n\t\t\tSystem.err.println(\"XML loading failed.\");\n\t\t}\n\t\t\n\t\treturn dom;\n\t}\n}",
    "difficulty": 7.0,
    "explanation": "This code snippet is a Java program that demonstrates how to read an XML file, modify its contents, and write back to the same file.\n\nThe main method begins by creating a File object called \"xmlFile\" that represents an XML file named \"cars.xml\". It then calls the LoadXMLDocument method, passing the xmlFile object as a parameter. This method uses the DocumentBuilder and DocumentBuilderFactory classes to create a DOM (Document Object Model) representation of the XML file, which is returned as a Document object called \"dom\".\n\nThe program then gets all the elements with tag name \"owner\" in the XML file using the getElementsByTagName method and stores them in a NodeList called \"owners\". It then iterates through each owner element, sets the attribute \"name\" to \"Mike\" using the setAttribute method, and moves on to the next element.\n\nFinally, the program calls the WriteXMLDocument method, passing the \"dom\" and \"xmlFile\" objects as parameters. This method creates a TransformerFactory object, a Transformer object, a StreamResult object, and a DOMSource object. It then uses these objects to write the modified XML data back to the same file specified by the \"xmlFile\" object.\n\nThe WriteXMLDocument and LoadXMLDocument methods are private helper methods that handle writing and reading XML documents, respectively. The WriteXMLDocument method uses a Transformer object to write the modified DOM to the specified file, and the LoadXMLDocument method uses a DocumentBuilder object to parse the XML file and create a DOM representation of it."
  }
  ]
}